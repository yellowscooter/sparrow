package com.sparrow.domain;

// Generated May 19, 2007 7:57:54 PM by Hibernate Tools 3.2.0.b9

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.acegisecurity.GrantedAuthority;
import org.acegisecurity.GrantedAuthorityImpl;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.sparrow.service.bill.BillStatusEnum;
import com.sparrow.service.bill.MultiplePendingBillsException;
import com.sparrow.service.common.DateUtils;
import com.sparrow.service.deliveryrequest.DeliveryRequestServiceImpl;
import com.sparrow.service.user.ProductRequestAlreadyExistsException;
import com.sparrow.service.user.UserService;
import com.sparrow.service.util.GeneralUtils;

/**
 * User generated by hbm2java
 */
public class User implements org.acegisecurity.userdetails.UserDetails, java.io.Serializable {
  private static final Log logger = LogFactory.getLog(User.class);
  
  private int userId;
  
  /**
   * Version property used by Hibernate for application level transactions
   */
  private int version;

  /**
   * Username is same as User's email id
   */
  private String username;

  private String password;
  
  /**
   * used to verify the password...is not stored in the database.
   */
  private String confirmPassword;

  private String firstname;

  private String lastname;

  private String accountEnabled;
  
  private String gender;

  private String ageGroup;

  private String phone;
  
  private String mobilePhone;
  
  private City city = new City();

  private String paymentMethod;

  private Integer submissionCount;

  private Integer checkoutCount;
  
  private Date accountCreateDate;

  private Date lastLoginDate;
  
  private SubscriptionPlan subscriptionPlan;

  private Date startDate;

  private Date expirationDate;

  private Address billingAddress = new Address();

  private Address shippingAddress = new Address();
  
  private String acceptTerms;
  
  private String status;
  
  private Integer statusUpdatedBy;
  
  private Date statusUpdateDate;

  /**
   * This is the Product Queue created by the user.
   * These are the Products they want to get in near future.
   */
  //private List productRequests = new LinkedList();
  private List productRequests = new ArrayList();

  private Set userRoles = new HashSet(0);
  
  /**
   * List of all payments made by a User
   */
  private Set payments = new HashSet();
  
  /**
   * All user Bills
   */
  private Set bills = new HashSet();
  
  /**
   * The current pending bill of the User. A user can only have one pending bill at a time.
   * The {@link UserService#getUserByUserName(String)} and {@link UserService#getUserById(int)} methods 
   * populate the pending bill, for convenienct access later (rather than looking for Pending bill in a Set)
   */
  private Bill pendingBill;
  
  /**
   * The last bill that the user paid....this field is here for convenient access.
   * The last paid bill also tells me which plan the user is currently on. The subscriptionPlan field cannot be used for this info
   * since the subscriptionPlan may have been updated after the last bill payment, and will only come into affect after the
   * current plan term ends.
   */
  private Bill lastPaidBill;
  
  //We do not want to user hibernate to fetch all the Products for a user for performance
  //Will use direct hibernate query to get this information.
  //private Set userProductsForUserId = new HashSet(0);
  
  /*
   * Indicates if a user is active or not...default is NULL, which means active
   * Y means inactive
   */
  //private String isInactive;
  
  /**
   * List of all notes that have been attached to a user account
   */
  private Set userNotes = new HashSet();
  
  /**
   * List of all Products that are currently with the user
   */
  private Set userProducts = new HashSet();
  
  /**
   * Special delivery instructions the user may have given.
   */
  private String deliveryInstructions;
  
  
  public User() {
  }
  
   /**
   * Constructor.
   * @param userId
   * @param username
   * @param password
   * @param firstname
   * @param lastname
   * @param email
   * @param enabled
   * @param userRoles
   * @since 1.0
   */
  public User(String username, String password, String firstname, String lastname, String enabled) {
    super();
    this.username = username;
    this.password = password;
    this.firstname = firstname;
    this.lastname = lastname;
    this.accountEnabled = enabled;
  }
  
  /**
   * If returns true, this is a transient instance (has not been persisted, or new instance)
   * If returns false, this is a persisted or detached instance (for edit)
   * @return
   * @since 1.0
   */
  public boolean isNew() {
    return (this.userId == 0);
  }

  public int getUserId() {
    return this.userId;
  }

  private void setUserId(int userId) {
    this.userId = userId;
  }
  
  public int getVersion() {
    return version;
  }

  private void setVersion(int version) {
    this.version = version;
  }

  public String getUsername() {
    return this.username;
  }

  /**
   * Setter for username...converts the username to lowercase since same email id 
   * with different case should be treated as duplicate.
   * @param username
   * @since 1.0
   */
  public void setUsername(String username) {
    this.username = username.toLowerCase();
  }

  public String getPassword() {
    return this.password;
  }

  public void setPassword(String password) {
    this.password = password;
  }
  
  

  public String getConfirmPassword() {
    return confirmPassword;
  }

  public void setConfirmPassword(String confirmPassword) {
    this.confirmPassword = confirmPassword;
  }

  public String getFirstname() {
    return this.firstname;
  }

  public void setFirstname(String firstname) {
    this.firstname = firstname;
  }

  public String getLastname() {
    return this.lastname;
  }

  public void setLastname(String lastname) {
    this.lastname = lastname;
  }
  
  /**
   * Return the full name of the User
   * @return
   * @since 1.0
   */
  public String getFullname() {
    return firstname + " " + lastname;
  }

  public String getAccountEnabled() {
    return this.accountEnabled;
  }

  public void setAccountEnabled(String enabled) {
    this.accountEnabled = enabled;
  }
  
  
  public String getAgeGroup() {
    return ageGroup;
  }

  public void setAgeGroup(String ageGroup) {
    if ("".equals(ageGroup)) {
      this.ageGroup = null;
    } else {
      this.ageGroup = ageGroup;  
    }
    
  }

  public Integer getCheckoutCount() {
    return checkoutCount;
  }

  public void setCheckoutCount(Integer checkoutCount) {
    this.checkoutCount = checkoutCount;
  }

  
  public Date getAccountCreateDate() {
    return accountCreateDate;
  }

  public void setAccountCreateDate(Date accountCreateDate) {
    this.accountCreateDate = accountCreateDate;
  }

  public Date getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(Date expirationDate) {
    this.expirationDate = expirationDate;
  }

  public String getGender() {
    return gender;
  }

  public void setGender(String gender) {
    this.gender = gender;
  }

  public String getGenderDescription() {
    return ("M".equals(gender) ? "Male" : "Female");
  }
  public Date getLastLoginDate() {
    return lastLoginDate;
  }

  public void setLastLoginDate(Date lastLoginDate) {
    this.lastLoginDate = lastLoginDate;
  }

  public String getPaymentMethod() {
    return paymentMethod;
  }

  public void setPaymentMethod(String paymentMethod) {
    if ("".equals(paymentMethod)) {
      this.paymentMethod = null;
    } else {
      this.paymentMethod = paymentMethod;
    }
  }

  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  
  public String getMobilePhone() {
    return mobilePhone;
  }

  public void setMobilePhone(String mobilePhone) {
    this.mobilePhone = mobilePhone;
  }

  public City getCity() {
    return city;
  }

  public void setCity(City city) {
    this.city = city;
  }
  
  public SubscriptionPlan getSubscriptionPlan() {
    return subscriptionPlan;
  }

  public void setSubscriptionPlan(SubscriptionPlan subscriptionPlan) {
    this.subscriptionPlan = subscriptionPlan;
  }

  public Date getStartDate() {
    return startDate;
  }

  public void setStartDate(Date startDate) {
    this.startDate = startDate;
  }

  public Integer getSubmissionCount() {
    return submissionCount;
  }

  public void setSubmissionCount(Integer submissionCount) {
    this.submissionCount = submissionCount;
  }
  
  public Address getBillingAddress() {
    return billingAddress;
  }

  public void setBillingAddress(Address billingAddress) {
    this.billingAddress = billingAddress;
  }

  public Address getShippingAddress() {
    return shippingAddress;
  }

  public void setShippingAddress(Address shippingAddress) {
    this.shippingAddress = shippingAddress;
  }
  
  
  public String getAcceptTerms() {
    return acceptTerms;
  }

  public void setAcceptTerms(String acceptTerms) {
    this.acceptTerms = acceptTerms;
  }

  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  public Date getStatusUpdateDate() {
    return statusUpdateDate;
  }

  public void setStatusUpdateDate(Date statusUpdateDate) {
    this.statusUpdateDate = statusUpdateDate;
  }

  public Integer getStatusUpdatedBy() {
    return statusUpdatedBy;
  }

  public void setStatusUpdatedBy(Integer statusUpdatedBy) {
    this.statusUpdatedBy = statusUpdatedBy;
  }

  public List getProductRequests() {
    return (List)productRequests;
  }

  public void setProductRequests(List productRequests) {
    this.productRequests = productRequests;
  }

  public Set getUserRoles() {
    return this.userRoles;
  }

  public void setUserRoles(Set userRoles) {
    this.userRoles = userRoles;
  }
  
  public Set getPayments() {
    return payments;
  }

  public void setPayments(Set payments) {
    this.payments = payments;
  }
  
  public Set getBills() {
    return bills;
  }

  public void setBills(Set bills) {
    this.bills = bills;
  }
  
  public Bill getPendingBill() {
    //status of the bill could have been updated by some other process, so also checking if the bill is pending
    if (this.pendingBill != null && this.pendingBill.getStatus().equals(BillStatusEnum.PENDING.getValue())) {
      return pendingBill;
    }
    
    Bill bill = null;
    Iterator itr = this.getBills().iterator();
    while (itr.hasNext()) {
      Bill tempBill = (Bill)itr.next();
      if (tempBill.getStatus().equals(BillStatusEnum.PENDING.getValue())) {
        if (bill != null) {
          throw new MultiplePendingBillsException("User with userid, username : " + this.getUserId() + ", " + this.getUsername()
                                                    + "has multiple pending Bills");
        } 
        bill = tempBill;
      }
      
    }
    
    return bill;
  }
  
  
  
  /**
   * Fetches the last {@link Bill} that the user Paid. If User has not paid any bill, then returns null
   * @return
   * @since 1.0
   */
  public Bill getLastPaidBill() {
    Bill bill = null;
    int maxBillId = 0;
    
    Iterator itr = this.getBills().iterator();
    while (itr.hasNext()) {
      Bill tempBill = (Bill)itr.next();
      if (tempBill.getStatus().equals(BillStatusEnum.PAID.getValue())) {
        if (tempBill.getBillId() > maxBillId)
          maxBillId = tempBill.getBillId();
          bill = tempBill;
      }
      
    }
    
    return bill;
    
  }

  /**
   * Checks if bill has been created for a User and returns true if a Paid or Pending bill exists.
   * If no {@link Bill} in {@link BillStatusEnum#PAID} or {@link BillStatusEnum#PENDING} status exists, returns false.
   * 
   * Note: Cancelled Bill is not considered since it will never be paid by the user, so  a cancelled Bill is a non billed user.
   * @return
   * @since 1.0
   */
  public boolean isUserBeenBilledOnce() {
    //  status of the bill could have been updated by some other process, so also checking if the bill is pending
    //if there is a pending bill, then this is not the first bill
    if (this.pendingBill != null && this.pendingBill.getStatus().equals(BillStatusEnum.PENDING.getValue())) {
      return true;
    }
    
    //if user has a paid bill, then this is not the first bill
    Iterator itr = this.getBills().iterator();
    while (itr.hasNext()) {
      Bill tempBill = (Bill)itr.next();
      if (tempBill.getStatus().equals(BillStatusEnum.PAID.getValue())) {
        return true;
      }
      
    }   
    
    return false;
  }
  
  
  public void setPendingBill(Bill pendingBill) {
    this.pendingBill = pendingBill;
  }

  /**
   * Add a user to a given role.
   * @param role
   * @throws IllegalStateException if the user instance is Transient
   * @since 1.0
   */
  public void addRoleToUser(String role) {
    if (this.isNew()) {
      throw new IllegalStateException("Cannot give role to a Transient User. Save the user first.username=" + this.username );
    }
    UserRole authority = new UserRole(new UserRoleId(this.getUserId(), role));
    this.userRoles.add(authority);
  }
  
  /**
   * Add a new ProductRequest to the queue if it is not already in queue.
   * 
   * @param productRequest
   * @throws ProductRequestAlreadyExistsException if the ProductRequest already exists in queue.
   * @since 1.0
   */
  public void addProductRequest(ProductRequest productRequest) throws ProductRequestAlreadyExistsException {
    if (isProductRequestAleadyInQueue(productRequest)) {
      throw new ProductRequestAlreadyExistsException();
    }
    //add this request to at the end of the List...set the priority of the instance
    this.productRequests.add(productRequest);  
    
  }
  
  /**
   * Add a new ProductRequest to the queue given a User and Product
   * if the request is not already in queue.
   * 
   * @param product
   * @throws ProductRequestAlreadyExistsException if the ProductRequest already exists in queue.
   * @since 1.0
   */
  public void addProductRequest(Product product) throws ProductRequestAlreadyExistsException {
    //ProductRequest productRequest = new ProductRequest(this, product);
    ProductRequest productRequest = new ProductRequest(product, new Date());
    addProductRequest(productRequest);
  }
  
  /**
   * Returns true of ProductRequest Queue already contains the {@link Product},
   * else returns false.
   * @param productRequest
   * @return
   * @since 1.0
   */
  public boolean isProductAlreadyInQueue(Product product) {
    return isProductRequestAleadyInQueue(new ProductRequest(product, new Date()));
  }
  
  /**
   * Returns true of ProductRequest Queue already contains the {@link Product},
   * else returns false.
   * @param productRequest
   * @return
   * @since 1.0
   */
  private boolean isProductRequestAleadyInQueue(ProductRequest productRequest) {
    boolean status = false;
    if (productRequests.contains(productRequest)) {
      status = true;
    }
    return status;    
  }
  
  /**
   * Remove the {@link ProductRequest} with a given priority.
   * 
   * @param index the priority of the request
   * @since 1.0
   */
  public void removeProductRequest(int index) {
    if (index < 0 || index >= this.productRequests.size()) {
      //no point to throw an exception...just do not do anything is index is out of range
//      throw new IllegalArgumentException("Index to remove is not within range: index=" + index 
//                                          + ", Size of list=" + this.productRequests.size());
    } else {
      this.productRequests.remove(index);  
    }
    
      
  }
  
  /**
   * Move the ProductRequest one level up in the ProductRequest list
   * Note: The priority field of ProductRequest instances in the List will become incorrect
   * after this call.
   * @param index the index of ProductRequest to be moved one level up
   * @return true if there was an update to the list, else false
   * 
   * @since 1.0
   */
  public boolean moveProductRequestOneUp(int index) {
    if (productRequests.size() == 0) { 
      return false;
    }
    boolean updateStatus = false;
    //move one up if element is not at head
    if (index != 0) {
      ProductRequest productRequest = (ProductRequest)this.productRequests.remove(index);
      this.productRequests.add(index - 1, productRequest);
      updateStatus = true;
    }
    return updateStatus;
    
  }
  
  /**
   * Move the ProductRequest one level down in the ProductRequest list
   * Note: The priority field of ProductRequest instances in the List will become incorrect
   * after this call.
   * @param index the index of ProductRequest to be moved one level down
   * @return true if there was an update to the list, else false
   * @since 1.0
   */
  public boolean moveProductRequestOneDown(int index) {
    if (productRequests.size() == 0) { 
      return false;
    }
    boolean updateStatus = false;
    //move down if not already at the tail of the list
    if (index != productRequests.size() - 1) {
      ProductRequest productRequest = (ProductRequest)this.productRequests.remove(index);
      this.productRequests.add(index + 1, productRequest);  
      updateStatus = true;
    }
    return updateStatus;    
  }
  
  /**
   * Move the ProductRequest to the head of the ProductRequest list
   * Note: The priority field of ProductRequest instances in the List will become incorrect
   * after this call.
   * @param index the index of ProductRequest to be moved to the head
   * @return true if there was an update to the list, else false
   * @since 1.0
   */
  public boolean moveProductRequestToHead(int index) {
    if (productRequests.size() == 0) { 
      return false;
    }
    boolean updateStatus = false;
    //move one up if element is not at head
    if (index != 0) {
      ProductRequest productRequest = (ProductRequest)this.productRequests.remove(index);
      this.productRequests.add(0, productRequest);
      updateStatus = true;
    }
    return updateStatus;
  }
  
  /**
   * Move the ProductRequest to the tail of the ProductRequest list
   * Note: The priority field of ProductRequest instances in the List will become incorrect
   * after this call.
   * @param index the index of ProductRequest to be moved to the tail
   * @return true if there was an update to the list, else false
   * @since 1.0
   */
  public boolean moveProductRequestToTail(int index) {
    if (productRequests.size() == 0) { 
      return false;
    }
    boolean updateStatus = false;
    //move down if not already at the tail of the list
    if (index != productRequests.size() - 1) {
      ProductRequest productRequest = (ProductRequest)this.productRequests.remove(index);
      this.productRequests.add(productRequest);
      updateStatus = true;
    }
    return updateStatus;
  }
  
  
  

  /**
   * 
   */
  public GrantedAuthority[] getAuthorities() {
    //assert this.getAuthoritieses() != null: "Granted Authorities cannot be null";
    GrantedAuthority[] grantedAutorities = new GrantedAuthority[this.getUserRoles().size()];
    Iterator itr = this.getUserRoles().iterator();
    int i = 0;
    while (itr.hasNext()) {
      UserRole auth = (UserRole)itr.next();
      String role = auth.getId().getRole(); 
      GrantedAuthority grantedAuthority = new GrantedAuthorityImpl(role);
      grantedAutorities[i++] = grantedAuthority;
      
    }
    return grantedAutorities;
  }

  /**
   * This attribute is not presently persisted, just returns true.
   */
  public boolean isAccountNonExpired() {
    return true;
  }

  /**
   * This attribute is not presently persisted, just returns true.
   */
  public boolean isAccountNonLocked() {
    return true;
  }

  /**
   * This attribute is not presently persisted, just returns true.
   */
  public boolean isCredentialsNonExpired() {
    return true;
  }

  /**
   * Required implementation for Acegi security.
   */
  public boolean isEnabled() {
    return ("Y".equals(this.getAccountEnabled()) ? true : false);
  }
  
  

//  public String getIsInactive() {
//    return isInactive;
//  }
//
//  public void setIsInactive(String isInactive) {
//    this.isInactive = isInactive;
//  }
  
  public Set getUserNotes() {
    return userNotes;
  }

  public void setUserNotes(Set userNotes) {
    this.userNotes = userNotes;
  }
  
  

  public Set getUserProducts() {
    return userProducts;
  }

  public void setUserProducts(Set userProducts) {
    this.userProducts = userProducts;
  }

  public String getDeliveryInstructions() {
    return deliveryInstructions;
  }

  public void setDeliveryInstructions(String deliveryInstructions) {
    this.deliveryInstructions = deliveryInstructions;
  }
  
  /**
   * Returns true if this User is a new registration.
   * @return true if new registration, else false
   * @since 1.0
   */
  public boolean isNewRegistration() {
    boolean isNewRegistration = false;
    
    if (this.getStartDate().equals(this.getExpirationDate())) {
      isNewRegistration = true;
    }
    return isNewRegistration;
  }

  /**
   * Returns the membership month start date relative to the referenceDate passed as param.
   * 
   * @param referenceDate
   * @return
   * @since 1.0
   */
  public Date getUserMembershipMonthStartDate(Date referenceDate) {
    Date membershipMonthStartDate = this.getStartDate();
    Date membershipMonthStartDatePlusOneMonth = DateUtils.addMonths(membershipMonthStartDate, 1); 
    
    while (membershipMonthStartDatePlusOneMonth.before(referenceDate)) {
      membershipMonthStartDate = DateUtils.addMonths(membershipMonthStartDate, 1);
      membershipMonthStartDatePlusOneMonth = DateUtils.addMonths(membershipMonthStartDatePlusOneMonth, 1);
    }
    
    return membershipMonthStartDate;
  }
  
  /**
   * Returns the membership month end date relative to the referenceDate passed as param.
   * @param referenceDate
   * @return
   * @since 1.0
   */
  public Date getUserMembershipMonthEndDate(Date referenceDate) {
//    Date membershipMonthExpirationDate = this.getExpirationDate();
//    Date membershipMonthStartDateMinusOneMonth = DateUtils.addMonths(membershipMonthExpirationDate, -1); 
//    
//    while (membershipMonthStartDateMinusOneMonth.after(referenceDate)) {
//      membershipMonthExpirationDate = DateUtils.addMonths(membershipMonthExpirationDate, -1);
//      membershipMonthStartDateMinusOneMonth = DateUtils.addMonths(membershipMonthStartDateMinusOneMonth, -1);
//    }
    
    Date membershipMonthExpirationDate = this.getUserMembershipMonthStartDate(referenceDate);
    //logger.warn(">>>>>>>>>>mem month start date = " + membershipMonthExpirationDate);
    membershipMonthExpirationDate = DateUtils.addMonths(membershipMonthExpirationDate, 1);
    //logger.warn(">>>>>>>>>>mem month start date plus 1 month = " + membershipMonthExpirationDate);
    membershipMonthExpirationDate = DateUtils.addDays(membershipMonthExpirationDate, -1);
    //logger.warn(">>>>>>>>>>mem month start date plus 1 month minus 1 day = " + membershipMonthExpirationDate);
    return membershipMonthExpirationDate;
  }
  
  
  /**
   * Returns the membership month start date relative to today.
   * @return
   * @since 1.0
   */
  public Date getCurrentUserMembershipMonthStartDate() {
    return getUserMembershipMonthStartDate(new Date());
  }
  
  /**
   * Returns the membership month end date relative to today.
   * @return
   * @since 1.0
   */
  public Date getCurrentUserMembershipMonthEndDate() {
    return getUserMembershipMonthEndDate(new Date());
  }

  @Override
  public int hashCode() {
    final int PRIME = 31;
    int result = 1;
    result = PRIME * result + ((accountEnabled == null) ? 0 : accountEnabled.hashCode());
    result = PRIME * result + ((firstname == null) ? 0 : firstname.hashCode());
    result = PRIME * result + ((lastname == null) ? 0 : lastname.hashCode());
    result = PRIME * result + ((password == null) ? 0 : password.hashCode());
    result = PRIME * result + userId;
    result = PRIME * result + ((username == null) ? 0 : username.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    final User other = (User) obj;
    if (accountEnabled != other.accountEnabled)
      return false;
    if (firstname == null) {
      if (other.firstname != null)
        return false;
    } else if (!firstname.equals(other.firstname))
      return false;
    if (lastname == null) {
      if (other.lastname != null)
        return false;
    } else if (!lastname.equals(other.lastname))
      return false;
    if (password == null) {
      if (other.password != null)
        return false;
    } else if (!password.equals(other.password))
      return false;
    if (userId != other.userId)
      return false;
    if (username == null) {
      if (other.username != null)
        return false;
    } else if (!username.equals(other.username))
      return false;
    return true;
  }

  /**
   * @see java.lang.Object#toString()
   */
  public String toString() {
    return new ToStringBuilder(this)
        .append("userId", this.userId)
        .append("username", this.username)
        .append("firstname", this.firstname)
        .append("lastname", this.lastname)
        .toString();
  }

  
  
  
  
  
  
  
  

}
